---
title: graph-lib API
sidebar_label: graph-lib
---

import TOCInline from '@theme/TOCInline';
import { TabbedCodeBlock } from '../../src/components/TabbedCodeBlock';
import { APISeparator } from '../../src/components/APISeparator';

The `graph-lib` library provides numerous functions for creating and working with directed graphs. Functionality is
generally split into the following categories: The [core](#core) functions provide basic functionality for creating,
editing, and accessing graphs and their components. The [layout](#layout) functions provide various methods for
assigning positions to nodes. The [traverse](#traverse) functions provide various methods for traversing and searching
graphs.

<TOCInline toc={toc}/>

## Types

### `Node<T>` {#node}

An immutable object with a string `id` and any additional properties defined by type `T`.

```typescript
type Node<T={}> = Immutable<T> & {
    readonly id: string
}
```

`Immutable<T>` is a TypeScript type from the [Immer](https://immerjs.github.io/immer/api) library used to convert
mutable types to immutable types.

### `Edge<T>` {#edge}

An immutable object with a string `id`, `source` and `target` node IDs defining node connectivity, and any additional
properties defined by type `T`.

```typescript
type Edge<T={}> = Immutable<T> & {
    readonly id: string
    readonly source: string
    readonly target: string
}
```

`Immutable<T>` is a TypeScript type from the [Immer](https://immerjs.github.io/immer/api) library used to convert
mutable types to immutable types.

### `Graph<N, E>` {#graph}

A graph composed of nodes of type `N` and edges of type `E`, where `N` extends [`Node`](#node) and `E`
extends [`Edge`](#edge). Graph objects should not be manually created; rather, use [`newGraph()`](#newGraph) to
generate a graph object from a set of nodes and edges.

```typescript
type Graph<N extends Node = Node, E extends Edge = Edge> = {

    // Map node IDs to nodes
    readonly nodes: { [id: string]: N }

    // Map edge IDs to edges
    readonly edges: { [id: string]: E }

    // Map target node IDs to source node IDs to array of edge IDs
    readonly predecessors: {
        [target: string]: {
            [source: string]: string[]
        }
    }

    // Map source node IDs to target node IDs to array of edge IDs
    readonly successors: {
        [source: string]: {
            [target: string]: string[]
        }
    }

    // Map node IDs to array of edge IDs
    readonly inedges: {
        [id: string]: string[]
    }

    // Map node IDs to array of edge IDs
    readonly outedges: {
        [id: string]: string[]
    }

}
```

## Core

The core functions of the `graph-lib` library provide basic functionality for creating, editing, and accessing graphs
and their components.

<APISeparator/>

### `newGraph(nodes?, edges?)` {#newGraph}

Create a new graph from an existing set of nodes and edges. If no nodes or edges are provided, an empty graph is
created. All node IDs must be unique among nodes and edge IDs must be unique among edges. All edge source and target
node IDs must refer to nodes in the `nodes` array.

**Type Definitions:**

```newGraph(nodes?: Node[], edges?: Edge[]): Graph```

**Arguments:**
* `nodes`: (Optional) An array of [Nodes](#node)
* `edges`: (Optional) An array of [Edges](#edge)

**Returns:**

A [Graph](#graph) composed of all provided nodes and edges.

**Examples:**

<TabbedCodeBlock>

```typescript
const a: Node = { id: 'a' };
const b: Node = { id: 'b' };
const ab: Edge = { id: 'ab', source: 'a', target: 'b' };

// An empty graph
const graph: Graph = newGraph();

// A graph with one node
const graph: Graph = newGraph([a]);

// A graph with two nodes and one edge
const graph: Graph = newGraph([a, b], [ab]);
```

```javascript
const a = { id: 'a' };
const b = { id: 'b' };
const ab = { id: 'ab', source: 'a', target: 'b' };

// An empty graph
const graph = newGraph();

// A graph with one node
const graph = newGraph([a]);

// A graph with two nodes and one edge
const graph = newGraph([a, b], [ab]);
```

</TabbedCodeBlock>

<APISeparator/>

### `addEdge(graph, edge)` {#addEdge}

Add an edge to a graph. The new edge ID must be unique among all existing edge IDs, and the new edge's source and target
node IDs must refer to nodes that already exist in the graph.

**Type Definitions:**

`addEdge(graph: Graph, edge: Edge): Graph`

**Arguments:**
* `graph`: A [Graph](#graph) object
* `edge`: An [Edge](#edge) object

**Returns:**

A new [Graph](#graph) with the added edge

**Examples:**

<TabbedCodeBlock>

```typescript
const a: Node = { id: 'a' };
const b: Node = { id: 'b' };
const ab: Edge = { id: 'ab', source: 'a', target: 'b' };

const g0: Graph = newGraph([a, b]);
const g1: Graph = addEdge(g0, ab);
```

```javascript
const a = { id: 'a' };
const b = { id: 'b' };
const ab = { id: 'ab', source: 'a', target: 'b' };

const g0 = newGraph([a, b]);
const g1 = addEdge(g0, ab);
```

</TabbedCodeBlock>
<APISeparator/>

### `addEdges(graph, edges)` {#addEdges}

Add multiple edges to a graph. All new edge IDs must be unique among each other and all existing edge IDs. All new edge
source and target node IDs must refer to nodes that already exist in the graph.


**Type Definitions:**

`addEdges(graph: Graph, edges: Edge[]): Graph`

**Arguments:**
* `graph`: A [Graph](#graph) object
* `edges`: An array of [Edge](#edge) objects

**Returns:**

A new [Graph](#graph) with the added edges

**Examples:**

<TabbedCodeBlock>

```typescript
const a: Node = { id: 'a' };
const b: Node = { id: 'b' };
const ab: Edge = { id: 'ab', source: 'a', target: 'b' };
const ba: Edge = { id: 'ba', source: 'b', target: 'a' };

const g0: Graph = newGraph([a, b]);
const g1: Graph = addEdge(g0, [ab, ba]);
```

```javascript
const a = { id: 'a' };
const b = { id: 'b' };
const ab = { id: 'ab', source: 'a', target: 'b' };
const ba = { id: 'ba', source: 'b', target: 'a' };

const g0 = newGraph([a, b]);
const g1 = addEdge(g0, [ab, ba]);
```

</TabbedCodeBlock>
<APISeparator/>

### `addNode(graph, node)` {#addNode}

Add a node to a graph. The new node ID must be unique among all existing node IDs.

**Type Definitions:**

`addNode(graph: Graph, node: Node): Graph`

**Arguments:**
* `graph`: A [Graph](#graph) object
* `node`: A [Node](#node) object

**Returns:**

A new [Graph](#graph) with the added node

**Examples:**

<TabbedCodeBlock>

```typescript
const g0: Graph = newGraph();
const g1: Graph = addNode(g0, { id: 'a' });
const g2: Graph = addNode(g1, { id: 'b' });
```

```javascript
const g0 = newGraph();
const g1 = addNode(g0, { id: 'a' });
const g2 = addNode(g1, { id: 'b' });
```

</TabbedCodeBlock>

<APISeparator/>

### `addNodes(graph, nodes)` {#addNodes}

Add multiple nodes to a graph. All new node IDs must be unique among each other and all existing node IDs.

**Type Definitions:**

`addNodes(graph: Graph, nodes: Node[]): Graph`

**Arguments:**
* `graph`: A [Graph](#graph) object
* `nodes`: An array of [Node](#node) objects

**Returns:**

A new [Graph](#graph) with the added nodes

**Examples:**

<TabbedCodeBlock>

```typescript
const a: Node = { id: 'a' };
const b: Node = { id: 'b' };
const g0: Graph = newGraph();
const g1: Graph = addNodes(g0, [a, b]);
```

```javascript
const a = { id: 'a' };
const b = { id: 'b' };
const g0 = newGraph();
const g1 = addNodes(g0, [a, b]);
```

</TabbedCodeBlock>

<APISeparator/>

### `getEdge(graph, edgeID)` {#getEdge}

#### `getEdge(graph: Graph, edgeID: string): Edge | undefined`

### `getEdges(graph, edgeIDs)` {#getEdges}

#### `getEdges(graph: Graph, edgeIDs: string[]): (Edge | undefined)[]`

### `getNode(graph, nodeID)` {#getNode}

#### `getNode(graph: Graph, nodeID: string): Node | undefined`

### `getNodes(graph, nodeIDs)` {#getNodes}

#### `getNodes(graph: Graph, nodeIDs: string[]): (Node | undefined)[]`

### `getPredecessors(graph, nodeID)` {#getPredecessors}

`getPredecessors(graph: Graph, nodeID: string): Node[]`

### `getSuccessors(graph, nodeID)` {#getSuccessors}

#### `getSuccessors(graph: Graph, nodeID: string): Node[]`

### `hasEdge(graph, edgeID)` {#hasEdge}

#### `hasEdge(graph: Graph, edgeID: string): boolean`

### `hasEdges(graph, edgeIDs)` {#hasEdges}

#### `hasEdges(graph: Graph, edgeIDs: string[]): boolean`

### `hasNode(graph, nodeID)` {#hasNode}

#### `hasNode(graph: Graph, nodeID: string): boolean`

### `hasNodes(graph, nodeIDs)` {#hasNodes}

#### `hasNodes(graph: Graph, nodeIDs: string[]): boolean`

## Algorithms

### `getLeftwardEdges(graph, nodes)` {#getLeftwardEdges}

Given an ordered array of graph [nodes](#node), get all [edges](#edge) that have a source node index greater than
or equal to a target node index.

**Type Definitions:**

`getLeftwardEdges(graph: Graph, nodes: Node[]): Edge[]`

**Arguments:**
* `graph`: A [graph](#graph) object
* `nodes`: An ordered array of [nodes](#node) that exist in `graph`

**Returns:**

An array of edges whose source node indices are greater than or equal to their corresponding target node indices.

**Examples:**

<TabbedCodeBlock>

```typescript
const a: Node = { id: 'a' };
const b: Node = { id: 'b' };
const c: Node = { id: 'c' };
const ab: Edge = { id: 'ab', source: 'a', target: 'b' };
const bc: Edge = { id: 'bc', source: 'b', target: 'c' };
const ca: Edge = { id: 'ca', source: 'c', target: 'a' };
const g: Graph = newGraph([a, b, c], [ab, bc, ca]);

getLeftwardEdges(g, [a, b, c]);
// => [ca]

getLeftwardEdges(g, [b, c, a]);
// => [ab]
```

```javascript
const a = { id: 'a' };
const b = { id: 'b' };
const c = { id: 'c' };
const ab = { id: 'ab', source: 'a', target: 'b' };
const bc = { id: 'bc', source: 'b', target: 'c' };
const ca = { id: 'ca', source: 'c', target: 'a' };
const g = newGraph([a, b, c], [ab, bc, ca]);

getLeftwardEdges(g, [a, b, c]);
// => [ca]

getLeftwardEdges(g, [b, c, a]);
// => [ab]
```

</TabbedCodeBlock>

### `removeCyclesGreedy(graph)` {#removeCyclesGreedy}

Remove cycles from a graph using the Greedy Cycle Removal algorithm. The Greedy Cycle Removal algorithm finds a set of
edges, known as a [feedback arc set](https://en.wikipedia.org/wiki/Feedback_arc_set), which when removed from the graph
results in a new graph that has no cycles. This function finds the FAS and returns both the new graph and the set of
edges that were removed.

**P. Eades, X. Lin, and W. F. Smyth.** A fast and effective heuristic for the feedback arc set problem.
Information Processing Letters, 47(6):319–323, 1993.
[[pdf](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.47.7745&rep=rep1&type=pdf)]

**Type Definitions:**

`removeCyclesGreedy(graph: Graph<N, E>): [Graph<N, E>, E[]]`

**Arguments:**
* `graph`: A [graph](#graph) object

**Returns:**

An array, `[g, e]`, which is composed of the following:
* `g`: A [graph](#graph) with no cycles
* `e`: An array of [edges](#edges) that were removed from the input `graph` to create `g`

**Examples:**

<TabbedCodeBlock>

```typescript
const a: Node = { id: 'a' };
const b: Node = { id: 'b' };
const c: Node = { id: 'c' };
const ab: Edge = { id: 'ab', source: 'a', target: 'b' };
const bc: Edge = { id: 'bc', source: 'b', target: 'c' };
const ca: Edge = { id: 'ca', source: 'c', target: 'a' };
const aa: Edge = { id: 'aa', source: 'a', target: 'a' };
const g0: Graph = newGraph([a, b, c], [ab, bc, ca, aa]);

const [g1, removedEdges] = graphlib.removeCyclesGreedy(g0);
// => g1 is g0 with edges aa and bc removed
// => removedEdges = [aa, bc]
```

```javascript
const a = { id: 'a' };
const b = { id: 'b' };
const c = { id: 'c' };
const ab = { id: 'ab', source: 'a', target: 'b' };
const bc = { id: 'bc', source: 'b', target: 'c' };
const ca = { id: 'ca', source: 'c', target: 'a' };
const aa = { id: 'aa', source: 'a', target: 'a' };
const g0 = newGraph([a, b, c], [ab, bc, ca, aa]);

const [g1, removedEdges] = graphlib.removeCyclesGreedy(g0);
// => g1 is g0 with edges aa and bc removed
// => removedEdges = [aa, bc]
```

</TabbedCodeBlock>

## Layout

### `moveNode(graph, nodeID, position)` {#moveNode}

### `moveNodes(graph, nodeIDs, position)` {#moveNodes}

### `offsetNode(graph, nodeID, offset)` {#offsetNode}

### `offsetNodes(graph, nodeIDs, offset)` {#offsetNodes}

## Traverse

<APISeparator/>

### `breadthFirst(graph, nodeID, fn?)` {#breadthFirst}

Invokes the specified `fn` for the node with ID `nodeID` and each descendant in breadth-first order. The specified
function is passed the current descendant, the zero-based traversal index, and the node with ID `nodeID`. If the
function returns a truthy value, traversal is stopped. If no function is specified, an array of nodes in breadth-first
order is returned.

**Type Definitions:**

```typescript
breadthFirst(graph: Graph, nodeID: string): Node[]
breadthFirst(graph: Graph, nodeID: string, fn: (current: Node, index: number, node: Node) => boolean): void
```

**Arguments:**
* `graph`: A [Graph](#graph) object
* `nodeID`: ID of the node at which to begin traversal
* `fn`: (optional) A function with the following arguments:
  * `current`: The current descendant node
  * `index`: The zero-based traversal index
  * `node`: The node with ID `nodeID`
  * **Returns**: a boolean value indicating whether or not to terminate traversal

**Returns:**

If no function is specified, returns an array of [nodes](#node) in breadth-first order, otherwise nothing.

**Examples:**

```typescript
console.log('Coming soon...');
```

<APISeparator/>

### `depthFirst(graph, nodeID, fn?)` {#depthFirst}

<APISeparator/>

### `depthFirstPost(graph, nodeID, fn?)` {#depthFirstPost}

<APISeparator/>